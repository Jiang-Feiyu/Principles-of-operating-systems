Documentation of Assignment 1
## Test cases and sample output:
- Compile the program by `gcc JCshell.c -o ps1`
- Run the program by `./ps1`
- Like a traditional shell program, when the JCshell process is ready to accept input, it displays a prompt and waits for input from the user. The prompt should consist of the process ID of the JCshell.
- After accepting a line of input from the user, it parses the input line to extract the command name(s) and the associated argument list(s), and then creates the child process(es) to execute the command(s). We can assume that the command line is upper bound by 1024 characters with 30 strings at maximum (including the | symbols). When the child process(es) is/are running, JCshell should wait for the child process(es) to terminate before displaying the prompt for accepting the next input from the user. It will output same as the bash outputs.
```
## JCshell [128645] ## ls 
## JCshell [128645] ## ls -l
## JCshell [128645] ## pwd
## JCshell [128645] ## /student/21/ce/fyjiang/HKU-COMP3230A
## JCshell [128645] ## /student/21/ce/fyjiang/HKU-COMP3230A-
## JCshell [128645] ## gcc
```
- If the target program cannot be located or executed, JCshell displays an error message:
```
## JCshell [190902] ## simp
## JCshell [190902] ## /bin/simp
```
- `|` symbol - if the `|` (pipe) symbols appear in between commands in each input line, JCshell tries to create multiple child processes and "connects" the standard output of the command before `|` (pipe) and links it to the standard input of the command after `|` (pipe). That is, each command (except the first one) reads the previous command's output. We can assume that the user will not enter more than 4 pipes (i.e., 5 commands) in an input command line. 
- We can assume that it is incorrect to have the `|` sign as the first or last character on the input line. Also, it is incorrect to allow two `|` signs without a command in between. For example, when the user types:
```
## JCshell [373796] ## cat cpu-mechanisms.txt
## JCshell [373796] ## cat cpu-mechanisms.txt | grep trap
## JCshell [373796] ## cat cpu-mechanisms.txt | grep trap | wc -w
## JCshell [373796] ## ./tloop 10
## JCshell [373796] ## ./tloop 10 | ./tloop 5 | ./tloop 2
## JCshell [461797] ## cat cpu-mechanisms.txt |grep trap      
## JCshell [461797] ## cat cpu-mechanisms.txt || grep trap
## JCshell [461797] ## cat cpu-mechanisms.txt | | grep trap
## JCshell [461797] ## cat cpu-mechanisms.txt |  | grep trap
```
- SIGINT signal: The JCshell process and its child processes are required to respond to the SIGINT signal (generated by pressing Ctrl-c or kill command) according to the following guidelines: The JCshell process should not be terminated by SIGINT. When the user presses Ctrl-c while the JCshell process is waiting for input from the user, JCshell should react with a new prompt.
```
## JCshell [461797] ## ^C
## JCshell [461797] ## ^C
## JCshell [461797] ## ^C
```
- When the user presses Ctrl-c while the JCshell process is waiting for its child process(es) to terminate, the JCshell process should not be terminated, while the child process(es) should respond to the SIGINT signal according to the predefined behavior of the child command(s).
```
## JCshell [674776] ## ./tloop 10
^C
```
- built-in command: exit â€“ If the user enters the exit command, JCshell should terminate, and the standard shell prompt reappears.If the exit command has other arguments, JCshell would not treat it as a valid request and would not
terminate. In addition, if the exit command does not appear as the first word in the command line, JCshell would not treat it as the exit command.
```
## JCshell [695051] ## not exit
## JCshell [695051] ## exit now
## JCshell [695051] ## exit
## JCshell [695051] ## exit
JCshell: Terminated
fyjiang@workbench2:~/HKU-COMP3230A-Assigns/comp3230-Assi1$ ps
    PID TTY          TIME CMD
 691789 pts/115  00:00:00 bash
 727923 pts/115  00:00:00 ps
```
Reference:
1. tloop.c
```
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>		/* To handle various signals */
#include <unistd.h>

volatile int timer = 0;

void sigalrm_handler(int signum) {	
	printf("Time is up: %d seconds\nProgram terminated.\n", timer);
	exit(timer);
}

void main(int argc, char ** argv) {
	unsigned long long i, x;

	/* Install signal handler for SIGALRM */
	signal(SIGALRM, sigalrm_handler);
	
	if (argc > 2) {
		printf("Usage: ./loopf [second]\n");
		exit(0);
	} else if (argc == 2) {
		timer = atoi(argv[1]);
		alarm(timer);
	}

	x = 1;
	while (1) {
		for (i=0; i<1073741824; i += 2)
			x *= i;
			if (x > 8589934589)
				x = 1;
	}	

}
```